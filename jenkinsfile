pipeline {
  agent any

  // still fine to declare static build‐time parameters up here
  parameters {
    choice(
      name: 'terraformactions',
      choices: ['apply', 'destroy'],
      description: 'Choose your terraform action'
    )
  }

  environment {
    AWS_ACCESS_KEY_ID     = credentials('aws-access-key')
    AWS_SECRET_ACCESS_KEY = credentials('aws-secret-key')
  }

  stages {
    stage('Checkout') {
      steps {
        git branch: 'Terraform', url: 'https://github.com/Suhelk739/Devops.git'
      }
    }

    stage('Plan') {
      steps {
        sh 'terraform init'
        sh 'terraform plan -out=tfplan'
        sh 'terraform show -no-color > tfplan.txt'
      }
    }

    stage('Approval') {
      steps {
        // wrap any imperative logic in a script block
        script {
          // readFile (capital “F”) returns the contents of tfplan.txt
          def plan = readFile('tfplan.txt')

          // this will pause the pipeline and show the plan as a text parameter
          input(
            id: 'ApprovePlan', 
            message: 'Do you want to approve this plan?',
            parameters: [
              text(
                name: 'PLAN', 
                description: 'Review and confirm (you can modify if needed)', 
                defaultValue: plan
              )
            ]
          )
          // if you need to capture the edited PLAN, assign input() to a variable:
          // def userApprovedPlan = input( … )
        }
      }
    }

    stage('Apply or Destroy') {
      // only run this block if the choice param is apply or destroy
      when {
        expression {
          params.terraformactions in ['apply', 'destroy']
        }
      }
      steps {
        script {
          if (params.terraformactions == 'apply') {
            sh 'terraform apply -input=false tfplan'
          } else {
            sh 'terraform destroy -auto-approve'
          }
        }
      }
    }
  }
}
